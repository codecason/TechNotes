```
作为老员工，我这边看到的情况正好相反：最近新招的员工会 C++11 的不少。但是，对于这些新特性，把握不住，驾驭不了。

举几个我自己碰到过的例子，看看对你是否有帮助：

lambda 这东西好用，但是有个小伙动不动就用[&]。准确地说，要么是[]，要么是[&]。跟他讲道理，他跟我争论编译器会自动优化掉的。而且以前遇到编译问题都是加[&]解决的。

const 这种算是很古老特性了吧，有个小伙自己写的代码编译不过，然后把接口中的const去掉。然后顺便再去改几十处老代码，然后就编译过了。问他修改的理由，他说他觉得原来的接口有问题，导致他的代码编不过，所以他帮我改了——看他这意思还希望我夸夸！？

一小伙遇到一个进程crash问题，搞了一周找不出问题。最后Leader拉我去擦屁股。我一看代码直接麻了：这小伙的代码里到处都是智能指针。包括其他模块传过来的临时借用的对象。问他的代码里对象生命的周期怎么控制的，对象从属关系等等。答曰，直接用智能指针就可以了，不需要考虑。然后就给我科普几种智能指针的差别。

听说 C++11 有了右值引用，所以可以直接返回容器了。一小伙的代码里面就不在用指针和引用了。然后一个自定义的矩阵对象，直接内存异常。被其他人抓到问题后，让他修改。他百思不解，就拿过来问我到底问题在哪里。问了一下他自己的理解：原来他不了解右值引用构造和复制是干嘛用的。

tuple 好用吧，然后一小伙直接写了个8个成员的巨长的tuple。我 review 的时候给他提出来。他说不想再单独定义一个struct，tuple更简单。我看着那一堆的0、1、2、3、4、5、6、7 给他讲了一个多小时的代码可维护性是咋回事，然后他突然就悟了，说看来这些数字应该用enum class定义一下。

lambda 又想起一个：一小伙直接在一个函数里用了写了两个巨大的lambda。整个函数就除了十几其他代码，就剩下这两个lambda。他觉得，后面的两处函数调用各需要传入一 个function 参数，所以他就直接写了 lambda 函数了。

—————

不说了，好不容易起个早，太多负能量了。

—————

我感觉我就是你说的这样的老古董，我也确实经常跟这些小伙说：

多去看编程规范（我们内部定的）

没有充足的理由不要给我改老接口

拿不准的特性就不要用，放心，不会累s的

热点处理的代码，给我用原始的指针传数据，每个指针都给我先加上ASSERT再说。

除了UT代码可以随便折腾，业务代码不要硬套C++11的用法

接口层给我老老实实用C++98的特性和内部明确可以用的特性

软件行为不符合预期，首先全量重新编译一下，并把所有编译warning清掉，再看看

提代码前，本地把用例跑过，上主线前自己跑用例的时候开valgrind抓下内存问题

......

或许您可以和你们团队的老古董们沟通下，看看真实原因是什么。
```
