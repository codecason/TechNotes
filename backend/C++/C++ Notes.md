#### 内存管理
RTTI Run Time Type Identification 运行时类型识别
    typeid和dynamic_cast

RAII（Resource Acquisition In Initialization） 资源获取即初始化

迭代器如何设计

#### 2024

- install perf first
~~~
perf record -o my_trace.data <your-command-or-program>
timestamp=$(date +"%Y%m%d%H%M%S")
perf script -i my_trace.data | stackcollapse-perf.pl | flamegraph.pl > ../${timestamp}.svg
~~~

#### 2023-8-13 0012 C++工作 224228

作为老员工，我这边看到的情况正好相反：最近新招的员工会 C++11 的不少。但是，对于这些新特性，把握不住，驾驭不了。

举几个我自己碰到过的例子，看看对你是否有帮助：

lambda 这东西好用，但是有个小伙动不动就用[&]。准确地说，要么是[]，要么是[&]。跟他讲道理，他跟我争论编译器会自动优化掉的。而且以前遇到编译问题都是加[&]解决的。

const 这种算是很古老特性了吧，有个小伙自己写的代码编译不过，然后把接口中的const去掉。然后顺便再去改几十处老代码，然后就编译过了。问他修改的理由，他说他觉得原来的接口有问题，导致他的代码编不过，所以他帮我改了——看他这意思还希望我夸夸！？

一小伙遇到一个进程crash问题，搞了一周找不出问题。最后Leader拉我去擦屁股。我一看代码直接麻了：这小伙的代码里到处都是智能指针。包括其他模块传过来的临时借用的对象。问他的代码里对象生命的周期怎么控制的，对象从属关系等等。答曰，直接用智能指针就可以了，不需要考虑。然后就给我科普几种智能指针的差别。

听说 C++11 有了右值引用，所以可以直接返回容器了。一小伙的代码里面就不在用指针和引用了。然后一个自定义的矩阵对象，直接内存异常。被其他人抓到问题后，让他修改。他百思不解，就拿过来问我到底问题在哪里。问了一下他自己的理解：原来他不了解右值引用构造和复制是干嘛用的。

tuple 好用吧，然后一小伙直接写了个8个成员的巨长的tuple。我 review 的时候给他提出来。他说不想再单独定义一个struct，tuple更简单。我看着那一堆的0、1、2、3、4、5、6、7 给他讲了一个多小时的代码可维护性是咋回事，然后他突然就悟了，说看来这些数字应该用enum class定义一下。

lambda 又想起一个：一小伙直接在一个函数里用了写了两个巨大的lambda。整个函数就除了十几其他代码，就剩下这两个lambda。他觉得，后面的两处函数调用各需要传入一 个function 参数，所以他就直接写了 lambda 函数了。

—————

不说了，好不容易起个早，太多负能量了。

—————

我感觉我就是你说的这样的老古董，我也确实经常跟这些小伙说：

多去看编程规范（我们内部定的）

没有充足的理由不要给我改老接口

拿不准的特性就不要用，放心，不会累s的

热点处理的代码，给我用原始的指针传数据，每个指针都给我先加上ASSERT再说。

除了UT代码可以随便折腾，业务代码不要硬套C++11的用法

接口层给我老老实实用C++98的特性和内部明确可以用的特性

软件行为不符合预期，首先全量重新编译一下，并把所有编译warning清掉，再看看

提代码前，本地把用例跑过，上主线前自己跑用例的时候开valgrind抓下内存问题

......

或许您可以和你们团队的老古董们沟通下，看看真实原因是什么。

#### 
不瞒你讲，junior就这样。白天做需求，晚上看产品书，中午看大厂文章学习，有时间再练练UI，周末看思维书搞上升思维。休息时间玩竞品，看商业化。不举一反三扩大能力很容易被比下去。你可以做的简单，但想的要多。

产品书
大厂文章
思维书
商业化


第一篇：C++11的改进与现代化

第1章：使用C++11打造更简洁、更现代的程序
1.1 类型推导
1.1.1 auto 类型推导
1.1.2 decltype 关键字
1.1.3 返回类型后置语法—— auto 和 decltype 的结合使用
1.2 模板的细节改进
1.2.1 模板的右尖括号修正
1.2.2 模板的别名
1.2.3 函数模板的默认模板参数
1.3 列表初始化
1.3.1 统一的初始化
1.3.2 列表初始化的使用细节
1.3.3 初始化列表
1.3.4 防止类型收窄
1.4 基于范围的 for 循环
1.4.1 for 循环的新用法



|         | implement |      |
| ------- | --------- | ---- |
| auto    |           |      |
| lambda  |           |      |
| functor |           |      |



~~~
emplace_back
~~~



~~~
共享引用计数的不同的shared_ptr被多个线程写，是线程安全的。

对于线程中传入的外部shared_ptr对象，在线程内部进行一次新的构造，例如： sharedptr AObjTmp = outerSharedptrObj;
~~~
